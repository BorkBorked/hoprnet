// #![cfg_attr(docsrs, feature(doc_cfg, doc_auto_cfg))]

// mod handler;
// mod protocol;

// use handler::Handler;
// use libp2p_core::{Endpoint, Multiaddr};
// use libp2p_identity::PeerId;
// use libp2p_swarm::{
//     behaviour::FromSwarm, ConnectionDenied, ConnectionId, NetworkBehaviour, PollParameters,
//     THandler, THandlerInEvent, THandlerOutEvent, ToSwarm,
// };
// use std::time::Duration;
// use std::{
//     collections::VecDeque,
//     task::{Context, Poll},
// };

// pub use self::protocol::PROTOCOL_NAME;
// pub use handler::{Config, Failure};

// /// A [`NetworkBehaviour`] that responds to inbound pings and
// /// periodically sends outbound pings on every established connection.
// ///
// /// See the crate root documentation for more information.
// pub struct Behaviour {
//     /// Configuration for outbound pings.
//     config: Config,
//     /// Queue of events to yield to the swarm.
//     events: VecDeque<Event>,
// }

// /// Event generated by the `Ping` network behaviour.
// #[derive(Debug)]
// pub struct Event {
//     /// The peer ID of the remote.
//     pub peer: PeerId,
//     /// The connection the ping was executed on.
//     pub connection: ConnectionId,
//     /// The result of an inbound or outbound ping.
//     pub result: Result<Duration, Failure>,
// }

// impl Behaviour {
//     /// Creates a new `Ping` network behaviour with the given configuration.
//     pub fn new(config: Config) -> Self {
//         Self {
//             config,
//             events: VecDeque::new(),
//         }
//     }
// }

// impl Default for Behaviour {
//     fn default() -> Self {
//         Self::new(Config::new())
//     }
// }

// impl NetworkBehaviour for Behaviour {
//     type ConnectionHandler = Handler;
//     type ToSwarm = Event;

//     fn handle_established_inbound_connection(
//         &mut self,
//         _: ConnectionId,
//         peer: PeerId,
//         _: &Multiaddr,
//         _: &Multiaddr,
//     ) -> Result<THandler<Self>, ConnectionDenied> {
//         Ok(Handler::new(self.config.clone(), peer))
//     }

//     fn handle_established_outbound_connection(
//         &mut self,
//         _: ConnectionId,
//         peer: PeerId,
//         _: &Multiaddr,
//         _: Endpoint,
//     ) -> Result<THandler<Self>, ConnectionDenied> {
//         Ok(Handler::new(self.config.clone(), peer))
//     }

//     fn on_connection_handler_event(
//         &mut self,
//         peer: PeerId,
//         connection: ConnectionId,
//         result: THandlerOutEvent<Self>,
//     ) {
//         self.events.push_front(Event {
//             peer,
//             connection,
//             result,
//         })
//     }

//     fn poll(
//         &mut self,
//         _: &mut Context<'_>,
//         _: &mut impl PollParameters,
//     ) -> Poll<ToSwarm<Self::ToSwarm, THandlerInEvent<Self>>> {
//         if let Some(e) = self.events.pop_back() {
//             Poll::Ready(ToSwarm::GenerateEvent(e))
//         } else {
//             Poll::Pending
//         }
//     }

//     fn on_swarm_event(&mut self, event: FromSwarm<Self::ConnectionHandler>) {
//         match event {
//             FromSwarm::ConnectionEstablished(_)
//             | FromSwarm::ConnectionClosed(_)
//             | FromSwarm::AddressChange(_)
//             | FromSwarm::DialFailure(_)
//             | FromSwarm::ListenFailure(_)
//             | FromSwarm::NewListener(_)
//             | FromSwarm::NewListenAddr(_)
//             | FromSwarm::ExpiredListenAddr(_)
//             | FromSwarm::ListenerError(_)
//             | FromSwarm::ListenerClosed(_)
//             | FromSwarm::NewExternalAddrCandidate(_)
//             | FromSwarm::ExternalAddrExpired(_)
//             | FromSwarm::ExternalAddrConfirmed(_) => {}
//         }
//     }
// }

#[allow(dead_code)]
#[cfg(feature = "wasm")]
pub mod wasm {
    use utils_log::logger::JsLogger;
    use utils_misc::utils::wasm::JsResult;
    use wasm_bindgen::prelude::*;

    // When the `wee_alloc` feature is enabled, use `wee_alloc` as the global allocator.
    #[cfg(feature = "wee_alloc")]
    #[global_allocator]
    static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

    static LOGGER: JsLogger = JsLogger {};

    #[wasm_bindgen]
    pub fn core_libp2p_hopr_protocol_initialize_crate() {
        let _ = JsLogger::install(&LOGGER, None);

        // When the `console_error_panic_hook` feature is enabled, we can call the
        // `set_panic_hook` function at least once during initialization, and then
        // we will get better error messages if our code ever panics.
        //
        // For more details see
        // https://github.com/rustwasm/console_error_panic_hook#readme
        #[cfg(feature = "console_error_panic_hook")]
        console_error_panic_hook::set_once();
    }

    #[wasm_bindgen]
    pub fn core_libp2p_hopr_protocol_gather_metrics() -> JsResult<String> {
        utils_metrics::metrics::wasm::gather_all_metrics()
    }
}
